<!DOCTYPE html>
<html>
  <head>
    <title>Safety in Unsafe Rust</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <link rel="stylesheet" type="text/css" href="styles.css">
  </head>
  <body>
    <textarea id="source">
class: middle, center

# Reliable Unsafe Rust

### Achieving Memory Safety in Rust with Symbolic Verfication to Detect Leaky Abstractions

---
class: top, left

# Safe Rust
Rust is a systems language that guarentees memory safety at compile-time through
a set of rules. These rules allow the compiler to manage memory in a
provably safe way.

```rust
fn main() {
    let a = vec![1,2,3];
    let a2 = a;
    let a3 = a;
}
```

```text
error[E0382]: use of moved value: `a`
 --> src/main.rs:4:14
  |
3 |     let a2 = a;
  |              - value moved here
4 |     let a3 = a;
  |              ^ value used here after move
  |
```

---
class: top, left

# Unsafe Rust
Sometimes systems programming requires the ability to break the rules. The compiler
cannot reason about the context in which these unsafe actions are taken.

10% performance degredation in inflate if zeroed
```rust
if self.buffer.len() < pos_end as usize {
    unsafe {
        self.buffer.set_len(pos_end as usize);
    }
}
```

Abilities of unsafe:
* Dereference a raw pointer
* Call an unsafe function
* Access or modify a mutable static variable
* Implement an unsafe trait (Important for Drop)
---
class: top, left

# Leaky Undefined Behavior
```rust
if self.buffer.len() < pos_end as usize {
    unsafe {
        self.buffer.set_len(pos_end as usize);
    }
}

...

if dist == 0 {
  return Ok(left);
}

...

for i in self.pos..pos_end {
  self.buffer[i] = from[i-diff]
}

```

Possible undefined behavior from unsafe code (not all):
* Deference of null or dangling pointer
* Invalid values in primitive types (ie. null in box type)


---
class: top, left

# Symbolically Verify Unsafe Encapsulation

Safe functions that use unsafe code should not leave any memory in a potentially
unsound state.

Simple Cases (In Scope):
* Dereference of a null pointer
* Unaligned pointer reads
* Returning invalid values in primative types

Cases to look at in the future:
* leaking dangling pointers
* leaking unitialized memory
* OOB read/write

---
class: top, left

# Steps Moving Forward
1. Establish useful subset of language
2. Develop symbolic execution of this subset
3. Add additional constraints to discover leaky abstractions

    </textarea>
    <script src="https://remarkjs.com/downloads/remark-latest.min.js" type="text/javascript">
    </script>
    <script type="text/javascript">
      var slideshow = remark.create();
    </script>
  </body>
</html>
